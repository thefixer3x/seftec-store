
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL || import.meta.env.NEXT_PUBLIC_SUPABASE_URL || "";
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY || import.meta.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || "";

// Define the API endpoint that will be used for all backend services
// This will be used in a phased approach where api.seftec.store handles all backend services
const API_ENDPOINT = "https://api.seftec.store";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create Supabase client with error handling
let supabaseClient: any = null;

try {
  supabaseClient = createClient<Database>(
    SUPABASE_URL,
    SUPABASE_PUBLISHABLE_KEY,
    {
      auth: {
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: true,
        flowType: "pkce",
        // Configure authentication callbacks
        // Note: Using object notation that's compatible with the Supabase types
        storage: {
          getItem: (key) => {
            try {
              const storedSession = localStorage.getItem(key);
              return storedSession;
            } catch (error) {
              console.error('Error getting session from storage:', error);
              return null;
            }
          },
          setItem: (key, value) => {
            try {
              localStorage.setItem(key, value);
            } catch (error) {
              console.error('Error storing session:', error);
            }
          },
          removeItem: (key) => {
            try {
              localStorage.removeItem(key);
            } catch (error) {
              console.error('Error removing session:', error);
            }
          }
        }
      },
      global: {
        // Configure custom fetch function to use the API endpoint for functions
        fetch: (...args) => {
          const [url, options] = args;

          // Check if this is a function invocation request (matches /functions/invoke)
          if (typeof url === 'string' && url.includes('/functions/invoke')) {
            // Replace the URL with the new API endpoint
            // This is temporary until the proper DNS configuration is in place
            const newUrl = url.replace(SUPABASE_URL, API_ENDPOINT);
            return fetch(newUrl, options);
          }

          // For all other requests, use the default fetch behavior
          return fetch(url, options);
        }
      }
    }
  );
} catch (error) {
  console.error('âŒ Supabase client initialization failed:', error);
  console.error('Environment check:', {
    SUPABASE_URL,
    hasAnonKey: !!SUPABASE_PUBLISHABLE_KEY
  });

  // Create a complete mock client for development to prevent "not a function" errors
  const mockQueryBuilder = {
    select: function(query?: string) { return this; },
    insert: function(data: any) { return this; },
    update: function(data: any) { return this; },
    upsert: function(data: any) { return this; },
    delete: function() { return this; },
    eq: function(column: string, value: any) { return this; },
    neq: function(column: string, value: any) { return this; },
    gt: function(column: string, value: any) { return this; },
    gte: function(column: string, value: any) { return this; },
    lt: function(column: string, value: any) { return this; },
    lte: function(column: string, value: any) { return this; },
    like: function(column: string, pattern: string) { return this; },
    ilike: function(column: string, pattern: string) { return this; },
    is: function(column: string, value: any) { return this; },
    in: function(column: string, values: any[]) { return this; },
    contains: function(column: string, value: any) { return this; },
    containedBy: function(column: string, value: any) { return this; },
    range: function(from: number, to: number) { return this; },
    limit: function(count: number) { return this; },
    order: function(column: string, options?: any) { return this; },
    single: () => Promise.resolve({
      data: null,
      error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env')
    }),
    maybeSingle: () => Promise.resolve({
      data: null,
      error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env')
    }),
    then: function(resolve: any) {
      return Promise.resolve({
        data: null,
        error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env')
      }).then(resolve);
    }
  };

  supabaseClient = {
    auth: {
      getSession: () => Promise.resolve({ data: { session: null }, error: null }),
      getUser: () => Promise.resolve({ data: { user: null }, error: null }),
      signOut: () => Promise.resolve({ error: null }),
      signInWithOAuth: (credentials: any) => {
        console.error('ðŸš« signInWithOAuth called but Supabase is not initialized');
        return Promise.resolve({
          data: { provider: null, url: null },
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        });
      },
      signInWithOtp: (credentials: any) => {
        console.error('ðŸš« signInWithOtp called but Supabase is not initialized');
        return Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        });
      },
      signInWithPassword: (credentials: any) => {
        console.error('ðŸš« signInWithPassword called but Supabase is not initialized');
        return Promise.resolve({
          data: { user: null, session: null },
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        });
      },
      signUp: (credentials: any) => {
        console.error('ðŸš« signUp called but Supabase is not initialized');
        return Promise.resolve({
          data: { user: null, session: null },
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        });
      },
      resetPasswordForEmail: (email: string) => {
        console.error('ðŸš« resetPasswordForEmail called but Supabase is not initialized');
        return Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        });
      },
      updateUser: (attributes: any) => {
        console.error('ðŸš« updateUser called but Supabase is not initialized');
        return Promise.resolve({
          data: { user: null },
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        });
      },
      onAuthStateChange: (callback: any) => {
        console.warn('âš ï¸ onAuthStateChange called but Supabase is not initialized');
        return {
          data: { subscription: { unsubscribe: () => {} } },
          unsubscribe: () => {}
        };
      },
      mfa: {
        enroll: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        }),
        challenge: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        }),
        verify: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        }),
        unenroll: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        }),
        listFactors: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        }),
        getAuthenticatorAssuranceLevel: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        })
      }
    },
    from: (table: string) => {
      console.warn(`âš ï¸ Database query to '${table}' but Supabase is not initialized`);
      return mockQueryBuilder;
    },
    functions: {
      invoke: (functionName: string, options?: any) => {
        console.error(`ðŸš« Edge function '${functionName}' called but Supabase is not initialized`);
        return Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        });
      }
    },
    storage: {
      from: (bucket: string) => ({
        upload: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        }),
        download: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        }),
        remove: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        }),
        list: () => Promise.resolve({
          data: null,
          error: new Error('Supabase not initialized. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY in .env file.')
        }),
        getPublicUrl: (path: string) => ({
          data: { publicUrl: '' }
        })
      })
    }
  };
}

export const supabase = supabaseClient;

// Helper functions for authentication
export const getCurrentUser = async () => {
  if (!supabase?.auth?.getSession) return null;

  const { data: { session }, error } = await supabase.auth.getSession();

  if (error) {
    console.error('Error getting session:', error);
    return null;
  }

  return session?.user || null;
};

export const getCurrentUserId = async () => {
  const user = await getCurrentUser();
  return user?.id || null;
};

export const getUserProfile = async () => {
  const userId = await getCurrentUserId();

  if (!userId || !supabase?.from) return null;

  try {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId as string)
      .single();

    if (error) {
      console.error('Error fetching profile:', error);
      return null;
    }

    return data;
  } catch (error) {
    console.error('Error in getUserProfile:', error);
    return null;
  }
};
